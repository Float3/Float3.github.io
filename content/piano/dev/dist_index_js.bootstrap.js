"use strict";
/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunktuningplayground"] = self["webpackChunktuningplayground"] || []).push([["dist_index_js"],{

/***/ "./dist/MIDI.js":
/*!**********************!*\
  !*** ./dist/MIDI.js ***!
  \**********************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("﻿\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.requestMIDI = requestMIDI;\nexports.stopMIDIFile = stopMIDIFile;\nexports.playMIDIFile = playMIDIFile;\nconst _1 = __webpack_require__(/*! . */ \"./dist/index.js\");\nconst midi_1 = __webpack_require__(/*! @tonejs/midi */ \"./node_modules/@tonejs/midi/dist/Midi.js\");\nconst config_1 = __webpack_require__(/*! ./config */ \"./dist/config.js\");\nfunction requestMIDI() {\n    if (navigator.requestMIDIAccess) {\n        navigator.requestMIDIAccess().then(onMIDISuccess, onMIDIFailure);\n    }\n    else {\n        alert(\"WebMIDI is not supported in this browser.\");\n    }\n}\nfunction onMIDISuccess(midiAccess) {\n    const input = midiAccess.inputs.values().next().value;\n    if (input) {\n        input.onmidimessage = onMIDIMessage;\n    }\n    else {\n        alert(\"No MIDI input devices found.\");\n    }\n}\nfunction onMIDIFailure(error) {\n    console.error(\"MIDI Access failed:\", error);\n}\nfunction onMIDIMessage(event) {\n    const [status, tone_index, velocity] = event.data;\n    const is_note_on = (status & 240) === 144;\n    const is_note_off = (status & 240) === 128;\n    if (is_note_off) {\n        (0, _1.noteOff)(tone_index);\n    }\n    if (is_note_on) {\n        (0, _1.noteOn)(tone_index, velocity);\n    }\n}\nlet timeoutIds = [];\nfunction stopMIDIFile() {\n    timeoutIds.forEach((id) => clearTimeout(id));\n    timeoutIds = [];\n}\nfunction playMIDIFile(midiFile) {\n    const midi = new midi_1.Midi(midiFile);\n    midi.tracks.forEach((track) => {\n        const startTime = 0;\n        track.notes.forEach((note) => {\n            const noteOnTime = note.time * config_1.midiMultiplier - startTime;\n            const noteOffTime = (note.time + note.duration) * config_1.midiMultiplier - startTime;\n            const velocity = note.velocity;\n            if (velocity === 1)\n                note.velocity = 127;\n            const midiNote = note.midi;\n            timeoutIds.push(setTimeout(() => (0, _1.noteOn)(midiNote, velocity), noteOnTime));\n            timeoutIds.push(setTimeout(() => (0, _1.noteOff)(midiNote), noteOffTime));\n        });\n    });\n}\n\n\n//# sourceURL=webpack://tuningplayground/./dist/MIDI.js?");

/***/ }),

/***/ "./dist/Tone.js":
/*!**********************!*\
  !*** ./dist/Tone.js ***!
  \**********************/
/***/ ((__unused_webpack_module, exports) => {

eval("﻿\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Tone = void 0;\nexports.createTone = createTone;\nclass Tone {\n    index;\n    freq;\n    cents;\n    name;\n    node;\n    constructor(index, freq, cents, name, node) {\n        this.index = index;\n        this.freq = freq;\n        this.cents = cents;\n        this.name = name;\n        this.node = node;\n    }\n}\nexports.Tone = Tone;\nfunction createTone(index, freq, cents, name, oscillator) {\n    return new Tone(index, freq, cents, name, oscillator);\n}\n\n\n//# sourceURL=webpack://tuningplayground/./dist/Tone.js?");

/***/ }),

/***/ "./dist/UI.js":
/*!********************!*\
  !*** ./dist/UI.js ***!
  \********************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("﻿\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.volumeValue = exports.tranposeValue = exports.output = exports.volumeSlider = exports.tuningSelect = exports.playMarked = exports.shareMarked = exports.playButton = exports.markedButtons = exports.soundMethod = void 0;\nexports.play = play;\nexports.DOMContentLoaded = DOMContentLoaded;\nexports.handleTuningSelectChange = handleTuningSelectChange;\nexports.playingTonesChanged = playingTonesChanged;\nexports.logToDiv = logToDiv;\nexports.keyActive = keyActive;\nexports.markKey = markKey;\nexports.unmarkKey = unmarkKey;\nexports.markOrUnmarkKey = markOrUnmarkKey;\nexports.addEvents = addEvents;\nconst tslib_1 = __webpack_require__(/*! tslib */ \"./node_modules/tslib/tslib.es6.mjs\");\nconst wasm = tslib_1.__importStar(__webpack_require__(/*! wasm */ \"../tuningplayground/pkg/tuningplayground.js\"));\nconst abcjs = tslib_1.__importStar(__webpack_require__(/*! abcjs */ \"./node_modules/abcjs/index.js\"));\nconst _1 = __webpack_require__(/*! . */ \"./dist/index.js\");\nconst MIDI_1 = __webpack_require__(/*! ./MIDI */ \"./dist/MIDI.js\");\nconst octaveSize = document.getElementById(\"octaveSize\");\nconst stepSize = document.getElementById(\"stepSize\");\nconst fileInput = document.getElementById(\"fileInput\");\nexports.soundMethod = document.getElementById(\"soundMethod\");\nconst logContainer = document.getElementById(\"logContainer\");\nconst stepSizeParent = stepSize.parentElement;\nexports.markedButtons = document.getElementById(\"markedButtons\");\nexports.playButton = document.getElementById(\"playButton\");\nexports.shareMarked = document.getElementById(\"shareMarked\");\nexports.playMarked = document.getElementById(\"playMarked\");\nconst stopButton = document.getElementById(\"stopButton\");\nexports.tuningSelect = document.getElementById(\"tuningSelect\");\nexports.volumeSlider = document.getElementById(\"volumeSlider\");\nconst transpose = document.getElementById(\"transpose\");\nexports.output = document.getElementById(\"output\");\noctaveSize.onchange = handleTuningSelectChange;\nexports.tuningSelect.onchange = handleTuningSelectChange;\nstepSize.onchange = handleTuningSelectChange;\nfileInput.onchange = fileInputChange;\ntranspose.onchange = transposeChange;\nexports.volumeSlider.onchange = volumeChange;\nstopButton.onclick = stop;\nexports.playMarked.onclick = playMarkedKeys;\nexports.shareMarked.onclick = sharedMarkedKeys;\nexports.tranposeValue = 0;\nfunction transposeChange() {\n    exports.tranposeValue = parseInt(transpose.value);\n}\nexports.volumeValue = 0.25;\nfunction volumeChange() {\n    exports.volumeValue = parseFloat(exports.volumeSlider.value);\n}\nlet midiFile;\nlet midiFilePromise = null;\nfunction initOrGetMidiFile() {\n    if (!midiFilePromise) {\n        midiFilePromise = fetch(\"sample.mid\")\n            .then((response) => response.arrayBuffer())\n            .then((buffer) => {\n            midiFile = buffer;\n            return midiFile;\n        })\n            .catch((error) => {\n            console.error(error);\n            throw error;\n        });\n    }\n    return midiFilePromise;\n}\nfunction fileInputChange(event) {\n    return new Promise((resolve, reject) => {\n        const files = event.target.files;\n        if (files && files.length > 0) {\n            const reader = new FileReader();\n            reader.onload = (e) => {\n                midiFile = e.target.result;\n                midiFilePromise = Promise.resolve(midiFile);\n                resolve();\n            };\n            reader.onerror = reject;\n            reader.readAsArrayBuffer(files[0]);\n        }\n        else {\n            reject(new Error(\"No file selected\"));\n        }\n    });\n}\nfunction playMarkedKeys() {\n    _1.markedKeys.forEach((note) => (0, _1._noteOn)(note, undefined, true));\n    playingTonesChanged;\n}\nfunction sharedMarkedKeys() {\n    createAndCopyUrl(_1.markedKeys)();\n}\nfunction stop() {\n    (0, MIDI_1.stopMIDIFile)();\n}\nfunction play() {\n    initOrGetMidiFile().then(MIDI_1.playMIDIFile).catch(console.error);\n}\nfunction DOMContentLoaded() {\n    handleTuningSelectChange;\n}\nfunction handleTuningSelectChange() {\n    switch (exports.tuningSelect.value) {\n        case \"StepMethod\":\n            stepSizeParent.hidden = false;\n            stepSize.readOnly = false;\n            octaveSize.readOnly = false;\n            break;\n        case \"EqualTemperament\":\n            stepSizeParent.hidden = true;\n            stepSize.readOnly = true;\n            octaveSize.readOnly = false;\n            break;\n        default:\n            wasm.set_tuning_system(exports.tuningSelect.value, parseInt(octaveSize.value), parseInt(stepSize.value));\n            octaveSize.value = wasm.get_tuning_size().toString();\n            octaveSize.readOnly = true;\n            stepSize.hidden = true;\n            stepSize.readOnly = true;\n            break;\n    }\n    (0, _1.stopAllTones)();\n}\nfunction adjustOutputSize() {\n    exports.output.style.width = \"300px\";\n    exports.output.style.height = \"200px\";\n}\nfunction playingTonesChanged() {\n    const notes = Object.keys(_1.playingTones).map(Number);\n    if (notes.length === 0) {\n        abcjs.renderAbc(\"output\", 'X: 1\\nL: 1/1\\n|\"\"[u]|');\n        adjustOutputSize();\n        return;\n    }\n    let chordName;\n    const tones = Object.values(_1.playingTones)\n        .map((tone) => tone.name)\n        .join(\" \");\n    if (octaveSize.value === \"12\") {\n        const formatted_notes = wasm.convert_notes(tones.split(\" \"));\n        chordName = wasm.get_chord_name();\n        abcjs.renderAbc(\"output\", formatted_notes);\n        adjustOutputSize();\n    }\n    logToDiv(`${tones} | ${chordName}`, notes);\n}\nfunction createAndCopyUrl(keys) {\n    const hash = generateHash(keys);\n    const url = `${window.location.origin + window.location.pathname}#${hash}`;\n    return function () {\n        navigator.clipboard.writeText(url).catch(console.error);\n    };\n}\nfunction generateHash(keys) {\n    const hash = keys.join(\",\");\n    return hash;\n}\nfunction logToDiv(message, notes) {\n    const p = document.createElement(\"p\");\n    p.textContent = message;\n    const shareButton = document.createElement(\"button\");\n    shareButton.textContent = \"Share\";\n    shareButton.onclick = createAndCopyUrl(notes);\n    shareButton.style.marginRight = \"10px\";\n    p.style.marginLeft = \"10px\";\n    const div = document.createElement(\"div\");\n    div.style.display = \"flex\";\n    div.style.justifyContent = \"left\";\n    div.style.alignItems = \"center\";\n    div.appendChild(shareButton);\n    div.appendChild(p);\n    logContainer.insertBefore(div, logContainer.firstChild);\n}\nfunction keyActive(tone_index, active) {\n    const keyElement = document.querySelector(`div[data-note=\"${tone_index}\"]`);\n    if (keyElement) {\n        if (active)\n            keyElement.classList.add(\"key-active\");\n        else\n            keyElement.classList.remove(\"key-active\");\n    }\n}\nfunction markKey(tone_index) {\n    if (_1.markedKeys.includes(tone_index))\n        return;\n    _1.markedKeys.push(tone_index);\n    const keyElement = document.querySelector(`div[data-note=\"${tone_index}\"]`);\n    if (keyElement) {\n        keyElement.classList.add(\"key-marked\");\n    }\n    exports.markedButtons.style.display = \"block\";\n}\nfunction unmarkKey(tone_index) {\n    const index = _1.markedKeys.indexOf(tone_index);\n    if (index > -1) {\n        _1.markedKeys.splice(index, 1);\n    }\n    const keyElement = document.querySelector(`div[data-note=\"${tone_index}\"]`);\n    if (keyElement) {\n        keyElement.classList.remove(\"key-marked\");\n    }\n    if (_1.markedKeys.length === 0) {\n        exports.markedButtons.style.display = \"none\";\n    }\n}\nfunction markOrUnmarkKey(tone_index) {\n    const index = _1.markedKeys.indexOf(tone_index);\n    if (index > -1) {\n        unmarkKey(tone_index);\n    }\n    else {\n        markKey(tone_index);\n    }\n    _1.markedKeys.sort((a, b) => a - b);\n    window.location.hash = generateHash(_1.markedKeys);\n}\nfunction addEvents(key) {\n    const note = parseInt(key.getAttribute(\"data-note\"));\n    const addEvent = (eventName, callback) => {\n        key.addEventListener(eventName, callback);\n    };\n    key.addEventListener(\"mousedown\", (event) => {\n        const mouseEvent = event;\n        if (mouseEvent.ctrlKey) {\n            markOrUnmarkKey(note);\n        }\n        else {\n            (0, _1.noteOn)(note);\n        }\n    });\n    addEvent(\"mouseup\", () => (0, _1.noteOff)(note));\n    key.addEventListener(\"mouseenter\", (event) => {\n        const mouseEvent = event;\n        if (mouseEvent.ctrlKey) {\n            return;\n        }\n        (0, _1.noteOn)(note);\n    });\n    addEvent(\"mouseleave\", () => (0, _1.noteOff)(note));\n    addEvent(\"touchstart\", () => (0, _1.noteOn)(note));\n    addEvent(\"touchend\", () => (0, _1.noteOff)(note));\n}\n\n\n//# sourceURL=webpack://tuningplayground/./dist/UI.js?");

/***/ }),

/***/ "./dist/config.js":
/*!************************!*\
  !*** ./dist/config.js ***!
  \************************/
/***/ ((__unused_webpack_module, exports) => {

eval("﻿\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.midiMultiplier = void 0;\nexports.midiMultiplier = 1000;\n\n\n//# sourceURL=webpack://tuningplayground/./dist/config.js?");

/***/ }),

/***/ "./dist/events.js":
/*!************************!*\
  !*** ./dist/events.js ***!
  \************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("﻿\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.visibilityChange = visibilityChange;\nexports.onload = onload;\nexports.keydown = keydown;\nexports.keyup = keyup;\nconst tslib_1 = __webpack_require__(/*! tslib */ \"./node_modules/tslib/tslib.es6.mjs\");\nconst wasm = tslib_1.__importStar(__webpack_require__(/*! wasm */ \"../tuningplayground/pkg/tuningplayground.js\"));\nconst _1 = __webpack_require__(/*! . */ \"./dist/index.js\");\nconst _2 = __webpack_require__(/*! . */ \"./dist/index.js\");\nconst UI_1 = __webpack_require__(/*! ./UI */ \"./dist/UI.js\");\nfunction visibilityChange() {\n    if (document.hidden) {\n        (0, _2.stopAllTones)();\n    }\n}\nfunction onload() {\n    const hash = window.location.hash.substring(1);\n    if (hash) {\n        const notes = hash.split(\",\");\n        UI_1.markedButtons.style.display = \"flex\";\n        notes.forEach((note) => {\n            const index = parseInt(note);\n            (0, UI_1.markKey)(index);\n        });\n    }\n    else {\n        UI_1.markedButtons.style.display = \"none\";\n    }\n}\nfunction keydown(event) {\n    if (!document.hasFocus())\n        return;\n    if (event.repeat)\n        return;\n    if (event.code in _1.heldKeys)\n        return;\n    if (document.activeElement?.tagName === \"BODY\") {\n        const tone_index = wasm.from_keymap(event.code);\n        if (tone_index === -1)\n            return;\n        (0, _1.noteOn)(tone_index);\n        _1.heldKeys[event.code] = true;\n    }\n}\nfunction keyup(event) {\n    const tone_index = wasm.from_keymap(event.code);\n    if (tone_index === -1)\n        return;\n    (0, _1.noteOff)(tone_index);\n    delete _1.heldKeys[event.code];\n}\n\n\n//# sourceURL=webpack://tuningplayground/./dist/events.js?");

/***/ }),

/***/ "./dist/index.js":
/*!***********************!*\
  !*** ./dist/index.js ***!
  \***********************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("﻿\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.markedKeys = exports.heldKeys = exports.playingTones = void 0;\nexports.stopAllTones = stopAllTones;\nexports.noteOn = noteOn;\nexports._noteOn = _noteOn;\nexports.noteOff = noteOff;\nconst tslib_1 = __webpack_require__(/*! tslib */ \"./node_modules/tslib/tslib.es6.mjs\");\nconst wasm = tslib_1.__importStar(__webpack_require__(/*! wasm */ \"../tuningplayground/pkg/tuningplayground.js\"));\nconst Tone_1 = __webpack_require__(/*! ./Tone */ \"./dist/Tone.js\");\nconst MIDI_1 = __webpack_require__(/*! ./MIDI */ \"./dist/MIDI.js\");\nconst events_1 = __webpack_require__(/*! ./events */ \"./dist/events.js\");\nconst UI_1 = __webpack_require__(/*! ./UI */ \"./dist/UI.js\");\ndocument.addEventListener(\"DOMContentLoaded\", UI_1.DOMContentLoaded);\ndocument.addEventListener(\"visibilitychange\", events_1.visibilityChange);\nwindow.addEventListener(\"blur\", stopAllTones);\nwindow.addEventListener(\"hashchange\", events_1.onload);\nwindow.createTone = Tone_1.createTone;\nwasm\n    .default()\n    .then(() => {\n    (0, MIDI_1.requestMIDI)();\n    UI_1.playButton.onclick = UI_1.play;\n    document.addEventListener(\"keydown\", events_1.keydown);\n    document.addEventListener(\"keyup\", events_1.keyup);\n    document.querySelectorAll(\".white-key, .black-key\").forEach((key) => {\n        (0, UI_1.addEvents)(key);\n    });\n    (0, events_1.onload)();\n    (0, UI_1.playingTonesChanged)();\n})\n    .catch(console.error);\nexports.playingTones = [];\nexports.heldKeys = {};\nexports.markedKeys = [];\nfunction stopAllTones() {\n    Object.keys(exports.playingTones).forEach((key) => {\n        const tone_index = parseInt(key);\n        exports.playingTones[tone_index].node.stop();\n        delete exports.playingTones[tone_index];\n        (0, UI_1.keyActive)(tone_index, false);\n    });\n    (0, UI_1.playingTonesChanged)();\n}\nfunction noteOn(tone_index, velocity, cancel) {\n    _noteOn(tone_index, velocity, cancel);\n    (0, UI_1.playingTonesChanged)();\n}\nfunction _noteOn(tone_index, velocity, cancel) {\n    tone_index += UI_1.tranposeValue;\n    const tone = wasm.get_tone(tone_index);\n    const volume = Math.pow(UI_1.volumeValue, 2);\n    switch (UI_1.soundMethod.value) {\n        case \"native\":\n            playFrequencyNative(tone, volume).catch(console.error);\n            break;\n        case \"sample\":\n            playFrequencySample(tone, volume, cancel).catch(console.error);\n            break;\n    }\n    (0, UI_1.keyActive)(tone_index, true);\n}\nfunction noteOff(tone_index) {\n    tone_index += UI_1.tranposeValue;\n    if (!(tone_index in exports.playingTones))\n        return;\n    switch (UI_1.soundMethod.value) {\n        case \"native\":\n            exports.playingTones[tone_index].node.stop();\n            break;\n        case \"sample\":\n            break;\n    }\n    delete exports.playingTones[tone_index];\n    (0, UI_1.playingTonesChanged)();\n    (0, UI_1.keyActive)(tone_index, false);\n}\nlet audioContext = null;\nfunction initOrGetAudioContext() {\n    return new Promise((resolve, reject) => {\n        try {\n            if (!audioContext) {\n                audioContext = new window.AudioContext();\n            }\n            resolve(audioContext);\n        }\n        catch (error) {\n            reject(error);\n        }\n    });\n}\nlet audioBuffer = null;\nfunction initOrGetAudioBuffer() {\n    if (!audioBuffer) {\n        return fetch(\"a1.wav\")\n            .then((response) => response.arrayBuffer())\n            .then((arrayBuffer) => initOrGetAudioContext().then((context) => context.decodeAudioData(arrayBuffer)))\n            .then((newAudioBuffer) => {\n            audioBuffer = newAudioBuffer;\n            return audioBuffer;\n        });\n    }\n    else {\n        return Promise.resolve(audioBuffer);\n    }\n}\nasync function playFrequencySample(tone, volume, cancel) {\n    const localAudioContext = await initOrGetAudioContext();\n    const source = localAudioContext.createBufferSource();\n    source.buffer = await initOrGetAudioBuffer();\n    const gainNode = localAudioContext.createGain();\n    gainNode.gain.value = volume;\n    source.connect(gainNode);\n    gainNode.connect(localAudioContext.destination);\n    source.playbackRate.value = tone.freq / 220;\n    source.start();\n    tone.node = source;\n    exports.playingTones[tone.index] = tone;\n    (0, UI_1.playingTonesChanged)();\n    if (cancel) {\n        source.onended = () => {\n            noteOff(tone.index);\n        };\n    }\n}\nasync function playFrequencyNative(tone, volume) {\n    const localAudioContext = await initOrGetAudioContext();\n    const oscillator = localAudioContext.createOscillator();\n    const gainNode = localAudioContext.createGain();\n    gainNode.gain.value = volume;\n    gainNode.connect(localAudioContext.destination);\n    oscillator.type = \"square\";\n    oscillator.frequency.setValueAtTime(tone.freq, localAudioContext.currentTime);\n    oscillator.connect(gainNode);\n    oscillator.start();\n    tone.node = oscillator;\n    if (tone.index in exports.playingTones)\n        exports.playingTones[tone.index].node.stop();\n    exports.playingTones[tone.index] = tone;\n    (0, UI_1.playingTonesChanged)();\n}\n\n\n//# sourceURL=webpack://tuningplayground/./dist/index.js?");

/***/ }),

/***/ "../tuningplayground/pkg/tuningplayground_bg.wasm":
/*!********************************************************!*\
  !*** ../tuningplayground/pkg/tuningplayground_bg.wasm ***!
  \********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("module.exports = __webpack_require__.p + \"9f91b8f38904872aae44.wasm\";\n\n//# sourceURL=webpack://tuningplayground/../tuningplayground/pkg/tuningplayground_bg.wasm?");

/***/ }),

/***/ "../tuningplayground/pkg/tuningplayground.js":
/*!***************************************************!*\
  !*** ../tuningplayground/pkg/tuningplayground.js ***!
  \***************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   convert_notes: () => (/* binding */ convert_notes),\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__),\n/* harmony export */   from_keymap: () => (/* binding */ from_keymap),\n/* harmony export */   get_chord_name: () => (/* binding */ get_chord_name),\n/* harmony export */   get_tone: () => (/* binding */ get_tone),\n/* harmony export */   get_tuning_size: () => (/* binding */ get_tuning_size),\n/* harmony export */   initSync: () => (/* binding */ initSync),\n/* harmony export */   main: () => (/* binding */ main),\n/* harmony export */   set_tuning_system: () => (/* binding */ set_tuning_system)\n/* harmony export */ });\nlet wasm;\n\nlet WASM_VECTOR_LEN = 0;\n\nlet cachedUint8ArrayMemory0 = null;\n\nfunction getUint8ArrayMemory0() {\n    if (cachedUint8ArrayMemory0 === null || cachedUint8ArrayMemory0.byteLength === 0) {\n        cachedUint8ArrayMemory0 = new Uint8Array(wasm.memory.buffer);\n    }\n    return cachedUint8ArrayMemory0;\n}\n\nconst cachedTextEncoder = (typeof TextEncoder !== 'undefined' ? new TextEncoder('utf-8') : { encode: () => { throw Error('TextEncoder not available') } } );\n\nconst encodeString = (typeof cachedTextEncoder.encodeInto === 'function'\n    ? function (arg, view) {\n    return cachedTextEncoder.encodeInto(arg, view);\n}\n    : function (arg, view) {\n    const buf = cachedTextEncoder.encode(arg);\n    view.set(buf);\n    return {\n        read: arg.length,\n        written: buf.length\n    };\n});\n\nfunction passStringToWasm0(arg, malloc, realloc) {\n\n    if (typeof(arg) !== 'string') throw new Error(`expected a string argument, found ${typeof(arg)}`);\n\n    if (realloc === undefined) {\n        const buf = cachedTextEncoder.encode(arg);\n        const ptr = malloc(buf.length, 1) >>> 0;\n        getUint8ArrayMemory0().subarray(ptr, ptr + buf.length).set(buf);\n        WASM_VECTOR_LEN = buf.length;\n        return ptr;\n    }\n\n    let len = arg.length;\n    let ptr = malloc(len, 1) >>> 0;\n\n    const mem = getUint8ArrayMemory0();\n\n    let offset = 0;\n\n    for (; offset < len; offset++) {\n        const code = arg.charCodeAt(offset);\n        if (code > 0x7F) break;\n        mem[ptr + offset] = code;\n    }\n\n    if (offset !== len) {\n        if (offset !== 0) {\n            arg = arg.slice(offset);\n        }\n        ptr = realloc(ptr, len, len = offset + arg.length * 3, 1) >>> 0;\n        const view = getUint8ArrayMemory0().subarray(ptr + offset, ptr + len);\n        const ret = encodeString(arg, view);\n        if (ret.read !== arg.length) throw new Error('failed to pass whole string');\n        offset += ret.written;\n        ptr = realloc(ptr, len, offset, 1) >>> 0;\n    }\n\n    WASM_VECTOR_LEN = offset;\n    return ptr;\n}\n\nfunction isLikeNone(x) {\n    return x === undefined || x === null;\n}\n\nlet cachedDataViewMemory0 = null;\n\nfunction getDataViewMemory0() {\n    if (cachedDataViewMemory0 === null || cachedDataViewMemory0.buffer.detached === true || (cachedDataViewMemory0.buffer.detached === undefined && cachedDataViewMemory0.buffer !== wasm.memory.buffer)) {\n        cachedDataViewMemory0 = new DataView(wasm.memory.buffer);\n    }\n    return cachedDataViewMemory0;\n}\n\nfunction debugString(val) {\n    // primitive types\n    const type = typeof val;\n    if (type == 'number' || type == 'boolean' || val == null) {\n        return  `${val}`;\n    }\n    if (type == 'string') {\n        return `\"${val}\"`;\n    }\n    if (type == 'symbol') {\n        const description = val.description;\n        if (description == null) {\n            return 'Symbol';\n        } else {\n            return `Symbol(${description})`;\n        }\n    }\n    if (type == 'function') {\n        const name = val.name;\n        if (typeof name == 'string' && name.length > 0) {\n            return `Function(${name})`;\n        } else {\n            return 'Function';\n        }\n    }\n    // objects\n    if (Array.isArray(val)) {\n        const length = val.length;\n        let debug = '[';\n        if (length > 0) {\n            debug += debugString(val[0]);\n        }\n        for(let i = 1; i < length; i++) {\n            debug += ', ' + debugString(val[i]);\n        }\n        debug += ']';\n        return debug;\n    }\n    // Test for built-in\n    const builtInMatches = /\\[object ([^\\]]+)\\]/.exec(toString.call(val));\n    let className;\n    if (builtInMatches.length > 1) {\n        className = builtInMatches[1];\n    } else {\n        // Failed to match the standard '[object ClassName]'\n        return toString.call(val);\n    }\n    if (className == 'Object') {\n        // we're a user defined class or Object\n        // JSON.stringify avoids problems with cycles, and is generally much\n        // easier than looping through ownProperties of `val`.\n        try {\n            return 'Object(' + JSON.stringify(val) + ')';\n        } catch (_) {\n            return 'Object';\n        }\n    }\n    // errors\n    if (val instanceof Error) {\n        return `${val.name}: ${val.message}\\n${val.stack}`;\n    }\n    // TODO we could test for more things here, like `Set`s and `Map`s.\n    return className;\n}\n\nconst cachedTextDecoder = (typeof TextDecoder !== 'undefined' ? new TextDecoder('utf-8', { ignoreBOM: true, fatal: true }) : { decode: () => { throw Error('TextDecoder not available') } } );\n\nif (typeof TextDecoder !== 'undefined') { cachedTextDecoder.decode(); };\n\nfunction getStringFromWasm0(ptr, len) {\n    ptr = ptr >>> 0;\n    return cachedTextDecoder.decode(getUint8ArrayMemory0().subarray(ptr, ptr + len));\n}\n\nfunction main() {\n    wasm.main();\n}\n\nfunction logError(f, args) {\n    try {\n        return f.apply(this, args);\n    } catch (e) {\n        let error = (function () {\n            try {\n                return e instanceof Error ? `${e.message}\\n\\nStack:\\n${e.stack}` : e.toString();\n            } catch(_) {\n                return \"<failed to stringify thrown value>\";\n            }\n        }());\n        console.error(\"wasm-bindgen: imported JS function that was not marked as `catch` threw an error:\", error);\n        throw e;\n    }\n}\n\nfunction _assertNum(n) {\n    if (typeof(n) !== 'number') throw new Error(`expected a number argument, found ${typeof(n)}`);\n}\n/**\n * @param {number} index\n * @returns {any}\n */\nfunction get_tone(index) {\n    _assertNum(index);\n    const ret = wasm.get_tone(index);\n    return ret;\n}\n\n/**\n * @returns {number}\n */\nfunction get_tuning_size() {\n    const ret = wasm.get_tuning_size();\n    return ret >>> 0;\n}\n\n/**\n * @param {string} key\n * @returns {number}\n */\nfunction from_keymap(key) {\n    const ptr0 = passStringToWasm0(key, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n    const len0 = WASM_VECTOR_LEN;\n    const ret = wasm.from_keymap(ptr0, len0);\n    return ret;\n}\n\n/**\n * @returns {string}\n */\nfunction get_chord_name() {\n    let deferred1_0;\n    let deferred1_1;\n    try {\n        const ret = wasm.get_chord_name();\n        deferred1_0 = ret[0];\n        deferred1_1 = ret[1];\n        return getStringFromWasm0(ret[0], ret[1]);\n    } finally {\n        wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);\n    }\n}\n\nfunction addToExternrefTable0(obj) {\n    const idx = wasm.__externref_table_alloc();\n    wasm.__wbindgen_export_2.set(idx, obj);\n    return idx;\n}\n\nfunction passArrayJsValueToWasm0(array, malloc) {\n    const ptr = malloc(array.length * 4, 4) >>> 0;\n    const mem = getDataViewMemory0();\n    for (let i = 0; i < array.length; i++) {\n        mem.setUint32(ptr + 4 * i, addToExternrefTable0(array[i]), true);\n    }\n    WASM_VECTOR_LEN = array.length;\n    return ptr;\n}\n/**\n * @param {(string)[]} notes\n * @returns {string}\n */\nfunction convert_notes(notes) {\n    let deferred2_0;\n    let deferred2_1;\n    try {\n        const ptr0 = passArrayJsValueToWasm0(notes, wasm.__wbindgen_malloc);\n        const len0 = WASM_VECTOR_LEN;\n        const ret = wasm.convert_notes(ptr0, len0);\n        deferred2_0 = ret[0];\n        deferred2_1 = ret[1];\n        return getStringFromWasm0(ret[0], ret[1]);\n    } finally {\n        wasm.__wbindgen_free(deferred2_0, deferred2_1, 1);\n    }\n}\n\n/**\n * @param {string} tuning_system\n * @param {number} octave_size\n * @param {number} step_size\n */\nfunction set_tuning_system(tuning_system, octave_size, step_size) {\n    const ptr0 = passStringToWasm0(tuning_system, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n    const len0 = WASM_VECTOR_LEN;\n    _assertNum(octave_size);\n    _assertNum(step_size);\n    wasm.set_tuning_system(ptr0, len0, octave_size, step_size);\n}\n\nasync function __wbg_load(module, imports) {\n    if (typeof Response === 'function' && module instanceof Response) {\n        if (typeof WebAssembly.instantiateStreaming === 'function') {\n            try {\n                return await WebAssembly.instantiateStreaming(module, imports);\n\n            } catch (e) {\n                if (module.headers.get('Content-Type') != 'application/wasm') {\n                    console.warn(\"`WebAssembly.instantiateStreaming` failed because your server does not serve Wasm with `application/wasm` MIME type. Falling back to `WebAssembly.instantiate` which is slower. Original error:\\n\", e);\n\n                } else {\n                    throw e;\n                }\n            }\n        }\n\n        const bytes = await module.arrayBuffer();\n        return await WebAssembly.instantiate(bytes, imports);\n\n    } else {\n        const instance = await WebAssembly.instantiate(module, imports);\n\n        if (instance instanceof WebAssembly.Instance) {\n            return { instance, module };\n\n        } else {\n            return instance;\n        }\n    }\n}\n\nfunction __wbg_get_imports() {\n    const imports = {};\n    imports.wbg = {};\n    imports.wbg.__wbg_log_a57ddac862862ceb = function() { return logError(function (arg0, arg1) {\n        console.log(getStringFromWasm0(arg0, arg1));\n    }, arguments) };\n    imports.wbg.__wbg_error_ec258dcb769e372b = function() { return logError(function (arg0, arg1) {\n        console.error(getStringFromWasm0(arg0, arg1));\n    }, arguments) };\n    imports.wbg.__wbg_createTone_ee958f0cdcf79124 = function() { return logError(function (arg0, arg1, arg2, arg3, arg4, arg5) {\n        let deferred0_0;\n        let deferred0_1;\n        try {\n            deferred0_0 = arg3;\n            deferred0_1 = arg4;\n            const ret = createTone(arg0 >>> 0, arg1, arg2, getStringFromWasm0(arg3, arg4), arg5);\n            return ret;\n        } finally {\n            wasm.__wbindgen_free(deferred0_0, deferred0_1, 1);\n        }\n    }, arguments) };\n    imports.wbg.__wbg_error_f851667af71bcfc6 = function() { return logError(function (arg0, arg1) {\n        let deferred0_0;\n        let deferred0_1;\n        try {\n            deferred0_0 = arg0;\n            deferred0_1 = arg1;\n            console.error(getStringFromWasm0(arg0, arg1));\n        } finally {\n            wasm.__wbindgen_free(deferred0_0, deferred0_1, 1);\n        }\n    }, arguments) };\n    imports.wbg.__wbg_new_abda76e883ba8a5f = function() { return logError(function () {\n        const ret = new Error();\n        return ret;\n    }, arguments) };\n    imports.wbg.__wbg_stack_658279fe44541cf6 = function() { return logError(function (arg0, arg1) {\n        const ret = arg1.stack;\n        const ptr1 = passStringToWasm0(ret, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        const len1 = WASM_VECTOR_LEN;\n        getDataViewMemory0().setInt32(arg0 + 4 * 1, len1, true);\n        getDataViewMemory0().setInt32(arg0 + 4 * 0, ptr1, true);\n    }, arguments) };\n    imports.wbg.__wbindgen_string_get = function(arg0, arg1) {\n        const obj = arg1;\n        const ret = typeof(obj) === 'string' ? obj : undefined;\n        var ptr1 = isLikeNone(ret) ? 0 : passStringToWasm0(ret, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        var len1 = WASM_VECTOR_LEN;\n        getDataViewMemory0().setInt32(arg0 + 4 * 1, len1, true);\n        getDataViewMemory0().setInt32(arg0 + 4 * 0, ptr1, true);\n    };\n    imports.wbg.__wbindgen_debug_string = function(arg0, arg1) {\n        const ret = debugString(arg1);\n        const ptr1 = passStringToWasm0(ret, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        const len1 = WASM_VECTOR_LEN;\n        getDataViewMemory0().setInt32(arg0 + 4 * 1, len1, true);\n        getDataViewMemory0().setInt32(arg0 + 4 * 0, ptr1, true);\n    };\n    imports.wbg.__wbindgen_throw = function(arg0, arg1) {\n        throw new Error(getStringFromWasm0(arg0, arg1));\n    };\n    imports.wbg.__wbindgen_init_externref_table = function() {\n        const table = wasm.__wbindgen_export_2;\n        const offset = table.grow(4);\n        table.set(0, undefined);\n        table.set(offset + 0, undefined);\n        table.set(offset + 1, null);\n        table.set(offset + 2, true);\n        table.set(offset + 3, false);\n        ;\n    };\n\n    return imports;\n}\n\nfunction __wbg_init_memory(imports, memory) {\n\n}\n\nfunction __wbg_finalize_init(instance, module) {\n    wasm = instance.exports;\n    __wbg_init.__wbindgen_wasm_module = module;\n    cachedDataViewMemory0 = null;\n    cachedUint8ArrayMemory0 = null;\n\n\n    wasm.__wbindgen_start();\n    return wasm;\n}\n\nfunction initSync(module) {\n    if (wasm !== undefined) return wasm;\n\n\n    if (typeof module !== 'undefined') {\n        if (Object.getPrototypeOf(module) === Object.prototype) {\n            ({module} = module)\n        } else {\n            console.warn('using deprecated parameters for `initSync()`; pass a single object instead')\n        }\n    }\n\n    const imports = __wbg_get_imports();\n\n    __wbg_init_memory(imports);\n\n    if (!(module instanceof WebAssembly.Module)) {\n        module = new WebAssembly.Module(module);\n    }\n\n    const instance = new WebAssembly.Instance(module, imports);\n\n    return __wbg_finalize_init(instance, module);\n}\n\nasync function __wbg_init(module_or_path) {\n    if (wasm !== undefined) return wasm;\n\n\n    if (typeof module_or_path !== 'undefined') {\n        if (Object.getPrototypeOf(module_or_path) === Object.prototype) {\n            ({module_or_path} = module_or_path)\n        } else {\n            console.warn('using deprecated parameters for the initialization function; pass a single object instead')\n        }\n    }\n\n    if (typeof module_or_path === 'undefined') {\n        module_or_path = new URL(/* asset import */ __webpack_require__(/*! tuningplayground_bg.wasm */ \"../tuningplayground/pkg/tuningplayground_bg.wasm\"), __webpack_require__.b);\n    }\n    const imports = __wbg_get_imports();\n\n    if (typeof module_or_path === 'string' || (typeof Request === 'function' && module_or_path instanceof Request) || (typeof URL === 'function' && module_or_path instanceof URL)) {\n        module_or_path = fetch(module_or_path);\n    }\n\n    __wbg_init_memory(imports);\n\n    const { instance, module } = await __wbg_load(await module_or_path, imports);\n\n    return __wbg_finalize_init(instance, module);\n}\n\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (__wbg_init);\n\n\n//# sourceURL=webpack://tuningplayground/../tuningplayground/pkg/tuningplayground.js?");

/***/ })

}]);